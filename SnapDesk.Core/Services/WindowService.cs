using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using System.Diagnostics;
using Microsoft.Extensions.Logging;
using SnapDesk.Core;
using SnapDesk.Core.Interfaces;
using SnapDesk.Core.Exceptions;
using SnapDesk.Platform.Interfaces;
using SnapDesk.Shared;
using LiteDB;

namespace SnapDesk.Core.Services;

/// <summary>
/// Service for managing desktop window operations
/// </summary>
public class WindowService : IWindowService
{
    private readonly IWindowApi _windowApi;
    private readonly ILogger<WindowService> _logger;
	private readonly Dictionary<IntPtr, int> _monitorHandleToIndex = new();
	private int _nextMonitorIndex = 0;

    public WindowService(
        IWindowApi windowApi,
        ILogger<WindowService> logger)
    {
        _windowApi = windowApi ?? throw new ArgumentNullException(nameof(windowApi));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <summary>
    /// Gets all currently visible windows on the desktop
    /// </summary>
    /// <returns>Collection of window information</returns>
    public async Task<IEnumerable<WindowInfo>> GetCurrentWindowsAsync()
    {
        try
        {
            _logger.LogDebug("Getting current windows from platform layer");
            
            // Get all window handles from the platform layer
            var windowHandles = _windowApi.GetAllWindows();
            var windows = new List<WindowInfo>();

            foreach (var handle in windowHandles)
            {
                try
                {
                    // Check if window is valid and visible
                    if (!_windowApi.IsWindow(handle) || !_windowApi.IsWindowVisible(handle))
                        continue;

                    // Get window information
                    string title = string.Empty, className = string.Empty, titleError = string.Empty, classError = string.Empty, rectError = string.Empty;
                    Point position = new Point();
                    Size size = new Size();
                    
                    if (_windowApi.TryGetWindowText(handle, out title, out titleError) &&
                        _windowApi.TryGetClassName(handle, out className, out classError) &&
                        _windowApi.TryGetWindowRect(handle, out position, out size, out rectError))
                    {
                        // Get process information if available
                        var processId = 0;
                        var processName = string.Empty;
                        
                        if (_windowApi.TryGetWindowProcessId(handle, out var pid, out var pidError))
                        {
                            processId = pid;
                            try
                            {
                                // Resolve real process name from PID for long-term accuracy
                                processName = Process.GetProcessById(pid).ProcessName;
                            }
                            catch
                            {
                                // Fallback to placeholder if resolution fails
                            processName = $"Process_{pid}";
                            }
                        }

					// Determine window state
                        var state = WindowState.Normal;
                        try
                        {
                            if (_windowApi.IsWindowMinimized(handle)) state = WindowState.Minimized;
                            else if (_windowApi.IsWindowMaximized(handle)) state = WindowState.Maximized;
                        }
                        catch { /* best-effort */ }

					// Determine monitor index using platform monitor handle mapping
					int monitorIndex = GetMonitorIndexForWindow(handle);

                        // Create WindowInfo object
                        var windowInfo = new WindowInfo
                        {
                            // WindowId will be auto-generated by LiteDB when saved
                            ProcessName = processName,
                            WindowTitle = title ?? "Unknown Title",
                            ClassName = className ?? "Unknown Class",
                            Position = position,
                            Size = size,
                            State = state,
						Monitor = monitorIndex,
                            ZOrder = 0, // Default Z-order, will be enhanced later
                            IsVisible = true
                        };

                        windows.Add(windowInfo);
                        _logger.LogTrace("Added window: {Title} ({Class}) at ({X}, {Y}) {Width}x{Height}", 
                            title, className, position.X, position.Y, size.Width, size.Height);
                    }
                    else
                    {
                        _logger.LogDebug("Failed to get window info for handle {Handle}: Title={TitleError}, Class={ClassError}, Rect={RectError}", 
                            handle, titleError, classError, rectError);
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogWarning(ex, "Error processing window handle {Handle}", handle);
                }
            }

            _logger.LogInformation("Retrieved {Count} visible windows", windows.Count);
            return windows;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to get current windows");
            throw;
        }
    }

    /// <summary>
    /// Gets windows for a specific process
    /// </summary>
    /// <param name="processName">Name of the process</param>
    /// <returns>Collection of windows for the specified process</returns>
    public async Task<IEnumerable<WindowInfo>> GetWindowsByProcessAsync(string processName)
    {
        try
        {
            if (string.IsNullOrWhiteSpace(processName))
            {
                _logger.LogWarning("Process name is null or empty");
                return Enumerable.Empty<WindowInfo>();
            }

            _logger.LogDebug("Getting windows for process: {ProcessName}", processName);
            
            var allWindows = await GetCurrentWindowsAsync();
            var processWindows = allWindows.Where(w => 
                string.Equals(w.ProcessName, processName, StringComparison.OrdinalIgnoreCase));
                // No .ToList() - return IEnumerable directly

            _logger.LogDebug("Found {Count} windows for process {ProcessName}", processWindows.Count(), processName);
            return processWindows;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to get windows for process: {ProcessName}", processName);
            throw;
        }
    }

    /// <summary>
    /// Gets windows by title (partial match)
    /// </summary>
    /// <param name="title">Window title to search for</param>
    /// <returns>Collection of matching windows</returns>
    public async Task<IEnumerable<WindowInfo>> GetWindowsByTitleAsync(string title)
    {
        try
        {
            if (string.IsNullOrWhiteSpace(title))
            {
                _logger.LogWarning("Title is null or empty");
                return Enumerable.Empty<WindowInfo>();
            }

            _logger.LogDebug("Getting windows with title containing: {Title}", title);
            
            var allWindows = await GetCurrentWindowsAsync();
            var titleWindows = allWindows.Where(w => 
                !string.IsNullOrWhiteSpace(w.WindowTitle) && 
                w.WindowTitle.Contains(title, StringComparison.OrdinalIgnoreCase));
                // No .ToList() - return IEnumerable directly

            _logger.LogDebug("Found {Count} windows with title containing '{Title}'", titleWindows.Count(), title);
            return titleWindows;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to get windows by title: {Title}", title);
            throw;
        }
    }

    /// <summary>
    /// Gets windows by class name
    /// </summary>
    /// <param name="className">Window class name</param>
    /// <returns>Collection of windows with the specified class</returns>
    public async Task<IEnumerable<WindowInfo>> GetWindowsByClassAsync(string className)
    {
        try
        {
            if (string.IsNullOrWhiteSpace(className))
            {
                _logger.LogWarning("Class name is null or empty");
                return Enumerable.Empty<WindowInfo>();
            }

            _logger.LogDebug("Getting windows with class: {ClassName}", className);
            
            var allWindows = await GetCurrentWindowsAsync();
            var classWindows = allWindows.Where(w => 
                string.Equals(w.ClassName, className, StringComparison.OrdinalIgnoreCase));
                // No .ToList() - return IEnumerable directly

            _logger.LogDebug("Found {Count} windows with class '{ClassName}'", classWindows.Count(), className);
            return classWindows;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to get windows by class: {ClassName}", className);
            throw;
        }
    }

    public async Task<bool> RestoreWindowAsync(WindowInfo window)
    {
        if (window == null) return false;
        var handle = await FindWindowByInfoAsync(window);
        if (handle == IntPtr.Zero) return false;

        // Move/resize first, then apply state and visibility
        var setBounds = _windowApi.TrySetWindowBounds(handle, window.Position.X, window.Position.Y, window.Size.Width, window.Size.Height, out var boundsErr);
        if (!setBounds) _logger.LogWarning("Failed to set bounds during restore: {Error}", boundsErr);

        // Set window state directly using platform API since we have the handle
        bool stateOk = false;
        string stateError = string.Empty;
        switch (window.State)
        {
            case WindowState.Minimized:
                stateOk = _windowApi.TryMinimizeWindow(handle, out stateError);
                break;
            case WindowState.Maximized:
                stateOk = _windowApi.TryMaximizeWindow(handle, out stateError);
                break;
            default:
                stateOk = _windowApi.TryRestoreWindow(handle, out stateError);
                break;
        }
        if (!stateOk) _logger.LogWarning("Failed to set state during restore for {Id}: {Error}", window.WindowId, stateError);

        if (window.IsVisible)
        {
            _ = _windowApi.TryShowWindow(handle, out _);
        }
        else
        {
            _ = _windowApi.TryHideWindow(handle, out _);
        }

        return true;
    }

    public async Task<int> RestoreWindowsAsync(IEnumerable<WindowInfo> windows)
    {
        if (windows == null) return 0;
        int restored = 0;
        foreach (var w in windows)
        {
            if (await RestoreWindowAsync(w)) restored++;
        }
        return restored;
    }

    public async Task<bool> SaveWindowStateAsync(WindowInfo window)
    {
        try
        {
            if (window == null) return false;
            var handle = await FindWindowByInfoAsync(window);
            if (handle == IntPtr.Zero) return false;

            if (_windowApi.TryGetWindowRect(handle, out var pos, out var size, out _))
            {
                window.Position = pos;
                window.Size = size;
                window.State = _windowApi.IsWindowMinimized(handle) ? WindowState.Minimized : (_windowApi.IsWindowMaximized(handle) ? WindowState.Maximized : WindowState.Normal);
                window.IsVisible = _windowApi.IsWindowVisible(handle);
                window.Monitor = GetMonitorIndexForWindow(handle);
                return true;
            }
            return false;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "SaveWindowStateAsync failed");
            return false;
        }
    }
    public async Task<bool> MoveWindowAsync(ObjectId windowId, Point position)
    {
        if (!TryParseWindowId(windowId, out var handle)) return false;
        var ok = _windowApi.TryMoveWindow(handle, position.X, position.Y, out var error);
        if (!ok) _logger.LogWarning("MoveWindow failed: {Error}", error);
        return await Task.FromResult(ok);
    }

    public async Task<bool> ResizeWindowAsync(ObjectId windowId, Size size)
    {
        if (!TryParseWindowId(windowId, out var handle)) return false;
        var ok = _windowApi.TryResizeWindow(handle, size.Width, size.Height, out var error);
        if (!ok) _logger.LogWarning("ResizeWindow failed: {Error}", error);
        return await Task.FromResult(ok);
    }

    public async Task<bool> SetWindowStateAsync(ObjectId windowId, WindowState state)
    {
        if (!TryParseWindowId(windowId, out var handle)) return false;
        bool ok = false;
        string error = string.Empty;
        switch (state)
        {
            case WindowState.Minimized:
                ok = _windowApi.TryMinimizeWindow(handle, out error);
                break;
            case WindowState.Maximized:
                ok = _windowApi.TryMaximizeWindow(handle, out error);
                break;
            default:
                ok = _windowApi.TryRestoreWindow(handle, out error);
                break;
        }
        if (!ok) _logger.LogWarning("SetWindowState to {State} failed: {Error}", state, error);
        return await Task.FromResult(ok);
    }

    public async Task<bool> ShowWindowAsync(ObjectId windowId)
    {
        if (!TryParseWindowId(windowId, out var handle)) return false;
        var ok = _windowApi.TryShowWindow(handle, out var error);
        if (!ok) _logger.LogWarning("ShowWindow failed: {Error}", error);
        return await Task.FromResult(ok);
    }

    public async Task<bool> HideWindowAsync(ObjectId windowId)
    {
        if (!TryParseWindowId(windowId, out var handle)) return false;
        var ok = _windowApi.TryHideWindow(handle, out var error);
        if (!ok) _logger.LogWarning("HideWindow failed: {Error}", error);
        return await Task.FromResult(ok);
    }

    public async Task<bool> BringWindowToFrontAsync(ObjectId windowId)
    {
        if (!TryParseWindowId(windowId, out var handle)) return false;
        var ok = _windowApi.TryBringWindowToFront(handle, out var error);
        if (!ok) _logger.LogWarning("BringWindowToFront failed: {Error}", error);
        return await Task.FromResult(ok);
    }





    public Task<IntPtr> FindWindowByInfoAsync(WindowInfo windowInfo)
    {
        try
        {
            if (windowInfo == null)
                return Task.FromResult(IntPtr.Zero);

            // If a valid window ID is provided and points to a live window, return it immediately
            if (windowInfo.WindowId != ObjectId.Empty && TryParseWindowId(windowInfo.WindowId, out var parsedHandle))
            {
                if (_windowApi.IsWindow(parsedHandle))
                    return Task.FromResult(parsedHandle);
            }

            var handles = _windowApi.GetAllWindows();
            foreach (var handle in handles)
            {
                if (!_windowApi.IsWindow(handle))
                    continue;

                // Gather attributes for matching
                _ = _windowApi.TryGetWindowText(handle, out var title, out _);
                _ = _windowApi.TryGetClassName(handle, out var className, out _);
                var processName = string.Empty;
                if (_windowApi.TryGetWindowProcessId(handle, out var pid, out _))
                {
                    try { processName = Process.GetProcessById(pid).ProcessName; }
                    catch { processName = string.Empty; }
                }

                // Match all provided non-empty criteria (case-insensitive; title as contains)
                var matches = true;
                if (!string.IsNullOrWhiteSpace(windowInfo.WindowTitle))
                {
                    matches &= !string.IsNullOrEmpty(title) && title.IndexOf(windowInfo.WindowTitle, StringComparison.OrdinalIgnoreCase) >= 0;
                }
                if (!string.IsNullOrWhiteSpace(windowInfo.ClassName))
                {
                    matches &= !string.IsNullOrEmpty(className) && className.Equals(windowInfo.ClassName, StringComparison.OrdinalIgnoreCase);
                }
                if (!string.IsNullOrWhiteSpace(windowInfo.ProcessName))
                {
                    var providedProcess = windowInfo.ProcessName;
                    bool procMatch;
                    if (TryParsePidPlaceholder(providedProcess, out var expectedPid))
                    {
                        // Match by PID when placeholder format is provided
                        procMatch = _windowApi.TryGetWindowProcessId(handle, out var actualPid, out _) && actualPid == expectedPid;
                    }
                    else
                    {
                        procMatch = !string.IsNullOrEmpty(processName) && processName.Equals(providedProcess, StringComparison.OrdinalIgnoreCase);
                    }
                    matches &= procMatch;
                }

                if (matches)
                    return Task.FromResult(handle);
            }

            return Task.FromResult(IntPtr.Zero);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to find window by info");
            return Task.FromResult(IntPtr.Zero);
        }
    }





    public async Task<IEnumerable<MonitorInfo>> GetMonitorConfigurationAsync()
    {
        try
        {
            var descriptors = _windowApi.GetAllMonitors();
            var monitors = new List<MonitorInfo>();
            foreach (var d in descriptors)
            {
                var mi = new MonitorInfo
                {
                    Index = d.Index,
                    IsPrimary = d.IsPrimary,
                    Bounds = new Rectangle(d.BoundsX, d.BoundsY, d.BoundsWidth, d.BoundsHeight),
                    WorkingArea = new Rectangle(d.WorkingX, d.WorkingY, d.WorkingWidth, d.WorkingHeight),
                    Dpi = d.Dpi,
                    RefreshRate = d.RefreshRate,
                    Name = string.IsNullOrWhiteSpace(d.Name) ? $"Monitor {d.Index}" : d.Name
                };
                monitors.Add(mi);
            }
            return await Task.FromResult(monitors.AsEnumerable());
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to get monitor configuration");
            throw;
        }
    }

    /// <summary>
    /// Gets the primary monitor information
    /// </summary>
    /// <returns>Primary monitor information</returns>
    public async Task<MonitorInfo> GetPrimaryMonitorAsync()
    {
        try
        {
            var monitors = await GetMonitorConfigurationAsync();
            var primaryMonitor = monitors.FirstOrDefault(m => m.IsPrimary);
            
            if (primaryMonitor == null)
            {
                _logger.LogWarning("No primary monitor found, using first available monitor");
                primaryMonitor = monitors.FirstOrDefault() ?? new MonitorInfo();
            }
            
            return primaryMonitor;
        		}
		catch (Exception ex)
		{
			_logger.LogError(ex, "Failed to get primary monitor");
			throw new SnapDeskException("Failed to get primary monitor", ex);
		}
    }

    public async Task<MonitorInfo?> GetMonitorByIndexAsync(int index)
    {
        var monitors = await GetMonitorConfigurationAsync();
        return monitors.FirstOrDefault(m => m.Index == index);
    }
    
    public async Task<IEnumerable<WindowInfo>> CaptureDesktopLayoutAsync()
    {
        var windows = await GetCurrentWindowsAsync();
        return windows;
    }

    /// <summary>
    /// Gets window statistics
    /// </summary>
    /// <returns>Statistics about current windows</returns>
    public async Task<WindowStatistics> GetWindowStatisticsAsync()
    {
        try
        {
            _logger.LogDebug("Getting window statistics");
            
            var allWindows = await GetCurrentWindowsAsync();
            // Materialize the collection only once for multiple operations
            var windowsList = allWindows.ToList(); // This .ToList() is necessary for multiple operations

            var statistics = new WindowStatistics
            {
                TotalWindows = windowsList.Count,
                VisibleWindows = windowsList.Count(w => w.IsVisible),
                MinimizedWindows = windowsList.Count(w => w.State == WindowState.Minimized),
                MaximizedWindows = windowsList.Count(w => w.State == WindowState.Maximized),
                NormalWindows = windowsList.Count(w => w.State == WindowState.Normal),
                WindowsOnPrimaryMonitor = windowsList.Count(w => w.Monitor == 0), // Assuming 0 is primary
                UniqueProcesses = windowsList.Select(w => w.ProcessName).Distinct().Count()
            };

            // Calculate most common process - optimize by avoiding multiple enumerations
            var processGroups = windowsList
                .GroupBy(w => w.ProcessName)
                .OrderByDescending(g => g.Count())
                .FirstOrDefault();
            
            statistics.MostCommonProcess = processGroups?.Key ?? "Unknown";

            // Calculate average window size
            if (windowsList.Any())
            {
                var totalWidth = windowsList.Sum(w => w.Size.Width);
                var totalHeight = windowsList.Sum(w => w.Size.Height);
                statistics.AverageWindowSize = new Size(
                    totalWidth / windowsList.Count,
                    totalHeight / windowsList.Count
                );

                // Calculate total window area
                statistics.TotalWindowArea = windowsList.Sum(w => w.Size.Width * w.Size.Height);
            }
            else
            {
                statistics.AverageWindowSize = new Size(0, 0);
                statistics.TotalWindowArea = 0;
            }

            _logger.LogDebug("Window statistics calculated: {TotalWindows} total, {VisibleWindows} visible, {UniqueProcesses} unique processes", 
                statistics.TotalWindows, statistics.VisibleWindows, statistics.UniqueProcesses);

            return statistics;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to get window statistics");
            throw;
        }
    }

    private static bool TryParseWindowId(ObjectId windowId, out IntPtr handle)
    {
        handle = IntPtr.Zero;
        try
        {
            // For now, we'll use a simple approach: convert ObjectId to a hash value
            // This is a temporary solution - in production, we'd want to store the actual window handle
            // or use a different approach for window identification
            var hash = windowId.GetHashCode();
            handle = new IntPtr(hash);
            return true;
        }
        catch
        {
            return false;
        }
    }

    private WindowInfo BuildWindowInfo(IntPtr handle, string? windowIdOverride = null)
    {
        string title = string.Empty, className = string.Empty;
        Point position = new Point();
        Size size = new Size();

        _ = _windowApi.TryGetWindowText(handle, out title, out _);
        _ = _windowApi.TryGetClassName(handle, out className, out _);
        _ = _windowApi.TryGetWindowRect(handle, out position, out size, out _);

        var processName = string.Empty;
        if (_windowApi.TryGetWindowProcessId(handle, out var pid, out _))
        {
            try { processName = Process.GetProcessById(pid).ProcessName; }
            catch { processName = $"Process_{pid}"; }
        }

        var state = WindowState.Normal;
        try
        {
            if (_windowApi.IsWindowMinimized(handle)) state = WindowState.Minimized;
            else if (_windowApi.IsWindowMaximized(handle)) state = WindowState.Maximized;
        }
        catch { /* best-effort */ }

        var windowInfo = new WindowInfo
        {
            // WindowId will be auto-generated by LiteDB when saved
            ProcessName = processName,
            WindowTitle = title ?? string.Empty,
            ClassName = className ?? string.Empty,
            Position = position,
            Size = size,
            State = state,
            Monitor = GetMonitorIndexForWindow(handle),
            ZOrder = 0,
            IsVisible = true
        };

        return windowInfo;
    }

    private static bool TryParsePidPlaceholder(string processName, out int pid)
    {
        pid = 0;
        if (string.IsNullOrWhiteSpace(processName))
            return false;
        if (!processName.StartsWith("Process_", StringComparison.OrdinalIgnoreCase))
            return false;
        var suffix = processName.Substring("Process_".Length);
        return int.TryParse(suffix, out pid);
    }

    private int GetMonitorIndexForWindow(IntPtr windowHandle)
    {
        try
        {
			if (_windowApi.TryGetWindowMonitor(windowHandle, out var monitorHandle, out _))
            {
				// Build mapping from platform-reported monitors to indices
				if (_monitorHandleToIndex.Count == 0)
				{
					var monitors = _windowApi.GetAllMonitors();
					foreach (var mon in monitors)
					{
						_monitorHandleToIndex[mon.Handle] = mon.Index;
						if (mon.Index >= _nextMonitorIndex) _nextMonitorIndex = mon.Index + 1;
					}
				}

				if (_monitorHandleToIndex.TryGetValue(monitorHandle, out var existingIndex))
					return existingIndex;

				// Fallback: assign next index to unknown handle
				var assignedIndex = _nextMonitorIndex++;
				_monitorHandleToIndex[monitorHandle] = assignedIndex;
				return assignedIndex;
            }
        }
        catch
        {
            // Fallthrough to default
        }
        // Default to primary monitor index 0 when unknown
        return 0;
    }

    /// <summary>
    /// Sends a window to the back (bottom of Z-order)
    /// </summary>
    /// <param name="windowId">Window identifier</param>
    /// <returns>True if send to back was successful</returns>
    public async Task<bool> SendWindowToBackAsync(ObjectId windowId)
    {
        if (!TryParseWindowId(windowId, out var handle)) return false;
        
        try
        {
            _logger.LogDebug("Sending window {WindowId} to back", windowId);
            
            // Send window to bottom of Z-order using SetWindowPos with HWND_BOTTOM (IntPtr(1))
            var moved = _windowApi.SetWindowPos(
                handle,
                new IntPtr(1),
                0,
                0,
                0,
                0,
                SetWindowPosFlags.SWP_NOMOVE | SetWindowPosFlags.SWP_NOSIZE | SetWindowPosFlags.SWP_NOACTIVATE);
            if (moved)
            {
                _logger.LogDebug("Successfully sent window {WindowId} to back", windowId);
                return true;
            }
            else
            {
                _logger.LogWarning("Failed to send window {WindowId} to back", windowId);
                return false;
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error sending window {WindowId} to back", windowId);
            return false;
        }
    }

    /// <summary>
    /// Moves a window to a different monitor
    /// </summary>
    /// <param name="windowId">Window identifier</param>
    /// <param name="monitorIndex">Target monitor index</param>
    /// <returns>True if monitor move was successful</returns>
    public async Task<bool> MoveWindowToMonitorAsync(ObjectId windowId, int monitorIndex)
    {
        if (!TryParseWindowId(windowId, out var handle)) return false;
        
        try
        {
            _logger.LogDebug("Moving window {WindowId} to monitor {MonitorIndex}", windowId, monitorIndex);
            
            // Get monitor information
            var monitors = _windowApi.GetAllMonitors();
            var targetMonitor = monitors.FirstOrDefault(m => m.Index == monitorIndex);
            if (targetMonitor == null)
            {
                _logger.LogWarning("Target monitor {MonitorIndex} not found", monitorIndex);
                return false;
            }
            
            // Move window to monitor center
            var centerX = targetMonitor.BoundsX + targetMonitor.BoundsWidth / 2;
            var centerY = targetMonitor.BoundsY + targetMonitor.BoundsHeight / 2;
            
            if (_windowApi.TryMoveWindow(handle, centerX, centerY, out var error))
            {
                _logger.LogDebug("Successfully moved window {WindowId} to monitor {MonitorIndex}", windowId, monitorIndex);
                return true;
            }
            else
            {
                _logger.LogWarning("Failed to move window {WindowId} to monitor {MonitorIndex}: {Error}", windowId, monitorIndex, error);
                return false;
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error moving window {WindowId} to monitor {MonitorIndex}", windowId, monitorIndex);
            return false;
        }
    }

    /// <summary>
    /// Gets detailed information about a specific window
    /// </summary>
    /// <param name="windowId">Window identifier</param>
    /// <returns>Detailed window information if found, null otherwise</returns>
    public async Task<WindowInfo?> GetWindowDetailsAsync(ObjectId windowId)
    {
        if (!TryParseWindowId(windowId, out var handle)) return null;
        
        try
        {
            _logger.LogDebug("Getting details for window {WindowId}", windowId);
            
            var windowInfo = BuildWindowInfo(handle, windowId.ToString());
            _logger.LogDebug("Retrieved details for window {WindowId}: {ProcessName} - {Title}", 
                windowId, windowInfo.ProcessName, windowInfo.WindowTitle);
            
            return windowInfo;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error getting details for window {WindowId}", windowId);
            return null;
        }
    }

    /// <summary>
    /// Refreshes window information (updates positions, states, etc.)
    /// </summary>
    /// <param name="windowId">Window identifier</param>
    /// <returns>Updated window information</returns>
    public async Task<WindowInfo?> RefreshWindowInfoAsync(ObjectId windowId)
    {
        if (!TryParseWindowId(windowId, out var handle)) return null;
        
        try
        {
            _logger.LogDebug("Refreshing information for window {WindowId}", windowId);
            
            var windowInfo = BuildWindowInfo(handle, windowId.ToString());
            _logger.LogDebug("Refreshed information for window {WindowId}: {ProcessName} - {Title}", 
                windowId, windowInfo.ProcessName, windowInfo.WindowTitle);
            
            return windowInfo;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error refreshing information for window {WindowId}", windowId);
            return null;
        }
    }

    /// <summary>
    /// Checks if a window is still valid/exists
    /// </summary>
    /// <param name="windowId">Window identifier</param>
    /// <returns>True if window is valid</returns>
    public async Task<bool> IsWindowValidAsync(ObjectId windowId)
    {
        if (!TryParseWindowId(windowId, out var handle)) return false;
        
        try
        {
            _logger.LogDebug("Checking validity of window {WindowId}", windowId);
            
            var isValid = _windowApi.IsWindow(handle);
            _logger.LogDebug("Window {WindowId} validity: {IsValid}", windowId, isValid);
            
            return isValid;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error checking validity of window {WindowId}", windowId);
            return false;
        }
    }
}
