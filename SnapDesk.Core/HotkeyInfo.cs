using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using LiteDB;

namespace SnapDesk.Core;

/// <summary>
/// Represents a keyboard shortcut (hotkey) for quick layout operations
/// </summary>
public class HotkeyInfo
{
    /// <summary>
    /// Unique identifier for the hotkey
    /// </summary>
    public ObjectId Id { get; set; }

    /// <summary>
    /// The key combination as a string (e.g., "Ctrl+Alt+1")
    /// </summary>
    [Required]
    [StringLength(50, MinimumLength = 1)]
    public string Keys { get; set; } = string.Empty;

    /// <summary>
    /// Individual modifier keys (Ctrl, Shift, Alt, Win)
    /// </summary>
    public List<ModifierKey> Modifiers { get; set; } = new();

    /// <summary>
    /// The main key (e.g., "1", "F1", "A")
    /// </summary>
    [Required]
    [StringLength(10, MinimumLength = 1)]
    public string Key { get; set; } = string.Empty;

    /// <summary>
    /// Whether this hotkey is currently enabled
    /// </summary>
    public bool IsEnabled { get; set; }

    /// <summary>
    /// What action this hotkey performs
    /// </summary>
    public HotkeyAction Action { get; set; }

    /// <summary>
    /// Optional layout ID if this hotkey is layout-specific
    /// </summary>
    public ObjectId? LayoutId { get; set; }

    /// <summary>
    /// When this hotkey was created
    /// </summary>
    public DateTime CreatedAt { get; set; }

    /// <summary>
    /// When this hotkey was last modified
    /// </summary>
    public DateTime UpdatedAt { get; set; }

    /// <summary>
    /// Default constructor
    /// </summary>
    public HotkeyInfo()
    {
        Id = ObjectId.NewObjectId(); // Generate a new ObjectId
        CreatedAt = DateTime.UtcNow;
        UpdatedAt = DateTime.UtcNow;
        IsEnabled = true;
    }

    /// <summary>
    /// Constructor with key combination
    /// </summary>
    /// <param name="keys">Key combination string</param>
    /// <param name="action">Action to perform</param>
    public HotkeyInfo(string keys, HotkeyAction action) : this()
    {
        Keys = keys;
        Action = action;
        // Id will be auto-generated by LiteDB
        ParseKeys(keys);
    }

    /// <summary>
    /// Constructor with key combination and layout
    /// </summary>
    /// <param name="keys">Key combination string</param>
    /// <param name="action">Action to perform</param>
    /// <param name="layoutId">Associated layout ID</param>
    public HotkeyInfo(string keys, HotkeyAction action, ObjectId layoutId) : this(keys, action)
    {
        LayoutId = layoutId;
    }



    /// <summary>
    /// Parses the key combination string into individual components
    /// </summary>
    /// <param name="keyString">Key combination string to parse</param>
    private void ParseKeys(string keyString)
    {
        if (string.IsNullOrWhiteSpace(keyString))
            throw new ArgumentException("Key string cannot be null or empty", nameof(keyString));

        var parts = keyString.Split('+');
        Modifiers.Clear();
        Key = string.Empty; // Reset key
        
        foreach (var part in parts)
        {
            var trimmedPart = part.Trim();
            
            // Use explicit string comparison instead of Enum.TryParse to avoid any enum parsing issues
            var isModifier = trimmedPart.Equals("Ctrl", StringComparison.OrdinalIgnoreCase) ||
                            trimmedPart.Equals("Shift", StringComparison.OrdinalIgnoreCase) ||
                            trimmedPart.Equals("Alt", StringComparison.OrdinalIgnoreCase) ||
                            trimmedPart.Equals("Win", StringComparison.OrdinalIgnoreCase);
            
            if (isModifier)
            {
                var modifier = trimmedPart.ToLower() switch
                {
                    "ctrl" => ModifierKey.Ctrl,
                    "shift" => ModifierKey.Shift,
                    "alt" => ModifierKey.Alt,
                    "win" => ModifierKey.Win,
                    _ => throw new ArgumentException($"Unknown modifier key: {trimmedPart}")
                };
                
                Modifiers.Add(modifier);
            }
            else
            {
                // If this is not a modifier, it's the main key
                // In case of multiple non-modifier parts, the last one wins
                Key = trimmedPart;
            }
        }

        if (string.IsNullOrWhiteSpace(Key))
            throw new ArgumentException("No valid key found in key combination", nameof(keyString));
    }

    /// <summary>
    /// Gets a display-friendly representation of the hotkey
    /// </summary>
    /// <returns>Formatted hotkey string</returns>
    public string GetDisplayString()
    {
        if (string.IsNullOrEmpty(Keys))
            return "Not Set";
        
        return Keys;
    }

    /// <summary>
    /// Checks if this hotkey conflicts with another hotkey
    /// </summary>
    /// <param name="other">Other hotkey to check</param>
    /// <returns>True if there's a conflict</returns>
    public bool ConflictsWith(HotkeyInfo other)
    {
        if (other == null) return false;
        return Keys.Equals(other.Keys, StringComparison.OrdinalIgnoreCase);
    }

    /// <summary>
    /// Enables this hotkey
    /// </summary>
    public void Enable()
    {
        IsEnabled = true;
        UpdatedAt = DateTime.UtcNow;
    }

    /// <summary>
    /// Disables this hotkey
    /// </summary>
    public void Disable()
    {
        IsEnabled = false;
        UpdatedAt = DateTime.UtcNow;
    }

    /// <summary>
    /// Updates the key combination
    /// </summary>
    /// <param name="newKeys">New key combination</param>
    public void UpdateKeys(string newKeys)
    {
        if (string.IsNullOrWhiteSpace(newKeys))
            throw new ArgumentException("Key combination cannot be null or empty", nameof(newKeys));

        Keys = newKeys;
        ParseKeys(newKeys);
        UpdatedAt = DateTime.UtcNow;
    }

    /// <summary>
    /// Updates the action
    /// </summary>
    /// <param name="newAction">New action</param>
    public void UpdateAction(HotkeyAction newAction)
    {
        Action = newAction;
        UpdatedAt = DateTime.UtcNow;
    }

    /// <summary>
    /// Associates this hotkey with a layout
    /// </summary>
    /// <param name="layoutId">Layout ID to associate with</param>
    public void AssociateWithLayout(ObjectId layoutId)
    {
        LayoutId = layoutId;
        UpdatedAt = DateTime.UtcNow;
    }

    /// <summary>
    /// Removes the layout association
    /// </summary>
    public void RemoveLayoutAssociation()
    {
        LayoutId = ObjectId.Empty;
        UpdatedAt = DateTime.UtcNow;
    }

    /// <summary>
    /// Checks if this hotkey is associated with a specific layout
    /// </summary>
    /// <param name="layoutId">Layout ID to check</param>
    /// <returns>True if associated with the specified layout</returns>
    public bool IsAssociatedWithLayout(ObjectId layoutId)
    {
        return LayoutId != ObjectId.Empty && LayoutId == layoutId;
    }

    /// <summary>
    /// Checks if this hotkey has any modifier keys
    /// </summary>
    /// <returns>True if has modifiers</returns>
    public bool HasModifiers => Modifiers.Count > 0;

    /// <summary>
    /// Checks if this hotkey has a specific modifier
    /// </summary>
    /// <param name="modifier">Modifier to check for</param>
    /// <returns>True if has the specified modifier</returns>
    public bool HasModifier(ModifierKey modifier)
    {
        return Modifiers.Contains(modifier);
    }

    /// <summary>
    /// Gets the number of modifier keys
    /// </summary>
    public int ModifierCount => Modifiers.Count;

    /// <summary>
    /// Checks if this hotkey is a simple key (no modifiers)
    /// </summary>
    /// <returns>True if simple key</returns>
    public bool IsSimpleKey => Modifiers.Count == 0;

    /// <summary>
    /// Gets a summary of the hotkey
    /// </summary>
    /// <returns>Formatted summary string</returns>
    public string GetSummary()
    {
        var layout = LayoutId != ObjectId.Empty ? $" for layout {LayoutId}" : "";
        var status = IsEnabled ? "Enabled" : "Disabled";
        return $"{Action} hotkey: {Keys}{layout} ({status})";
    }

    /// <summary>
    /// Validates the hotkey configuration
    /// </summary>
    /// <returns>True if valid, false otherwise</returns>
    public bool IsValid()
    {
        return Id != ObjectId.Empty &&
               !string.IsNullOrWhiteSpace(Keys) &&
               !string.IsNullOrWhiteSpace(Key) &&
               Modifiers.Count >= 0 &&
               Enum.IsDefined(typeof(HotkeyAction), Action);
    }

    /// <summary>
    /// Checks if this hotkey can be used
    /// </summary>
    /// <returns>True if hotkey is valid and enabled</returns>
    public bool CanBeUsed()
    {
        return IsValid() && IsEnabled;
    }
}

/// <summary>
/// Possible modifier keys for hotkeys
/// </summary>
public enum ModifierKey
{
    /// <summary>
    /// Control key
    /// </summary>
    Ctrl = 100,

    /// <summary>
    /// Shift key
    /// </summary>
    Shift = 101,

    /// <summary>
    /// Alt key
    /// </summary>
    Alt = 102,

    /// <summary>
    /// Windows key
    /// </summary>
    Win = 103
}

/// <summary>
/// Actions that can be performed by hotkeys
/// </summary>
public enum HotkeyAction
{
    /// <summary>
    /// Save the current desktop layout
    /// </summary>
    SaveLayout = 0,

    /// <summary>
    /// Restore a specific saved layout
    /// </summary>
    RestoreLayout = 1,

    /// <summary>
    /// Show/hide the main SnapDesk window
    /// </summary>
    ToggleMainWindow = 2,

    /// <summary>
    /// Quick save with auto-naming
    /// </summary>
    QuickSave = 3,

    /// <summary>
    /// Cycle through saved layouts
    /// </summary>
    CycleLayouts = 4
}
